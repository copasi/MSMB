/* Generated by JTB 1.4.4 */
package msmb.parsers.chemicalReaction.visitor;

import msmb.parsers.chemicalReaction.syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first order.<br>
 * In your "RetArgu" visitors extend this class and override part or all of these methods.
 *
 * @param <R> The user return information type
 * @param <A> The user argument type
 */
public class DepthFirstRetArguVisitor<R, A> implements IRetArguVisitor<R, A> {


  /*
   * Base nodes classes visit methods (to be overridden if necessary)
   */

  /**
   * Visits a {@link NodeChoice} node, passing it an argument.
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final NodeChoice n, final A argu) {
    final R nRes = n.choice.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link NodeList} node, passing it an argument.
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final NodeList n, final A argu) {
    R nRes = null;
    for (final Iterator<INode> e = n.elements(); e.hasNext();) {
      @SuppressWarnings("unused")
      final R sRes = e.next().accept(this, argu);
    }
    return nRes;
  }

  /**
   * Visits a {@link NodeListOptional} node, passing it an argument.
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final NodeListOptional n, final A argu) {
    if (n.present()) {
      R nRes = null;
      for (final Iterator<INode> e = n.elements(); e.hasNext();) {
        @SuppressWarnings("unused")
        R sRes = e.next().accept(this, argu);
        }
      return nRes;
    } else
      return null;
  }

  /**
   * Visits a {@link NodeOptional} node, passing it an argument.
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final NodeOptional n, final A argu) {
    if (n.present()) {
      final R nRes = n.node.accept(this, argu);
      return nRes;
    } else
    return null;
  }

  /**
   * Visits a {@link NodeSequence} node, passing it an argument.
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final NodeSequence n, final A argu) {
    R nRes = null;
    for (final Iterator<INode> e = n.elements(); e.hasNext();) {
      @SuppressWarnings("unused")
      R subRet = e.next().accept(this, argu);
    }
    return nRes;
  }

  /**
   * Visits a {@link NodeToken} node, passing it an argument.
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final NodeToken n, @SuppressWarnings("unused") final A argu) {
    R nRes = null;
    @SuppressWarnings("unused")
    final String tkIm = n.tokenImage;
    return nRes;
  }

  /*
   * User grammar generated visit methods (to be overridden if necessary)
   */

  /**
   * Visits a {@link CompleteReaction} node, whose children are the following :
   * <p>
   * reaction -> Reaction()<br>
   * nodeToken -> < EOF ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final CompleteReaction n, final A argu) {
    R nRes = null;
    final Reaction n0 = n.reaction;
    nRes = n0.accept(this, argu);
    final NodeToken n1 = n.nodeToken;
    nRes = n1.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link CompleteSpeciesWithCoefficient} node, whose children are the following :
   * <p>
   * speciesWithCoeff -> SpeciesWithCoeff()<br>
   * nodeToken -> < EOF ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final CompleteSpeciesWithCoefficient n, final A argu) {
    R nRes = null;
    final SpeciesWithCoeff n0 = n.speciesWithCoeff;
    nRes = n0.accept(this, argu);
    final NodeToken n1 = n.nodeToken;
    nRes = n1.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link Reaction} node, whose children are the following :
   * <p>
   * nodeChoice -> . %0 #0 ( AdditiveExpression() )?<br>
   * .......... .. . .. #1 ( Blank() )* #2 < ARROW ><br>
   * .......... .. . .. #3 ( $0 ( " " )<br>
   * .......... .. . .. .. . $1 ( Blank() )*<br>
   * .......... .. . .. .. . $2 ( AdditiveExpression() )? )*<br>
   * .......... .. . .. #4 ( $0 ( Blank() )* $1 ";"<br>
   * .......... .. . .. .. . $2 ( Blank() )* $3 ListModifiers() )?<br>
   * .......... .. | %1 #0 < ARROW2 ><br>
   * .......... .. . .. #1 ( Blank() )*<br>
   * .......... .. . .. #2 ( AdditiveExpression() )?<br>
   * .......... .. . .. #3 ( $0 ( Blank() )* $1 ";"<br>
   * .......... .. . .. .. . $2 ( Blank() )* $3 ListModifiers() )?<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final Reaction n, final A argu) {
    R nRes = null;
    final NodeChoice n0Ch = n.nodeChoice;
    final INode n0ChN = n0Ch.choice;
    switch (n0Ch.which) {
      case 0:
        final NodeSequence n0ChNSeq0 = (NodeSequence) n0ChN;
        final INode n0ChNSeq0A0 = n0ChNSeq0.elementAt(0);
        final NodeOptional n0ChNSeq0A0Opt = (NodeOptional) n0ChNSeq0A0;
        if (n0ChNSeq0A0Opt.present()) {
          nRes = n0ChNSeq0A0Opt.accept(this, argu);
        }
        final INode n0ChNSeq0A1 = n0ChNSeq0.elementAt(1);
        final NodeListOptional n0ChNSeq0A1Nlo = (NodeListOptional) n0ChNSeq0A1;
        if (n0ChNSeq0A1Nlo.present()) {
          for (int i = 0; i < n0ChNSeq0A1Nlo.size(); i++) {
            final INode n0ChNSeq0A1NloEi = n0ChNSeq0A1Nlo.elementAt(i);
            nRes = n0ChNSeq0A1NloEi.accept(this, argu);
          }
        }
        final INode n0ChNSeq0A2 = n0ChNSeq0.elementAt(2);
        nRes = n0ChNSeq0A2.accept(this, argu);
        final INode n0ChNSeq0A3 = n0ChNSeq0.elementAt(3);
        final NodeListOptional n0ChNSeq0A3Nlo = (NodeListOptional) n0ChNSeq0A3;
        if (n0ChNSeq0A3Nlo.present()) {
          for (int i = 0; i < n0ChNSeq0A3Nlo.size(); i++) {
            final INode n0ChNSeq0A3NloEi = n0ChNSeq0A3Nlo.elementAt(i);
            final NodeSequence n0ChNSeq0A3NloEiSeq = (NodeSequence) n0ChNSeq0A3NloEi;
            final INode n0ChNSeq0A3NloEiSeqA0 = n0ChNSeq0A3NloEiSeq.elementAt(0);
            nRes = n0ChNSeq0A3NloEiSeqA0.accept(this, argu);
            final INode n0ChNSeq0A3NloEiSeqA1 = n0ChNSeq0A3NloEiSeq.elementAt(1);
            final NodeListOptional n0ChNSeq0A3NloEiSeqA1Nlo = (NodeListOptional) n0ChNSeq0A3NloEiSeqA1;
            if (n0ChNSeq0A3NloEiSeqA1Nlo.present()) {
              for (int i1 = 0; i1 < n0ChNSeq0A3NloEiSeqA1Nlo.size(); i1++) {
                final INode n0ChNSeq0A3NloEiSeqA1NloEi = n0ChNSeq0A3NloEiSeqA1Nlo.elementAt(i1);
                nRes = n0ChNSeq0A3NloEiSeqA1NloEi.accept(this, argu);
              }
            }
            final INode n0ChNSeq0A3NloEiSeqA2 = n0ChNSeq0A3NloEiSeq.elementAt(2);
            final NodeOptional n0ChNSeq0A3NloEiSeqA2Opt = (NodeOptional) n0ChNSeq0A3NloEiSeqA2;
            if (n0ChNSeq0A3NloEiSeqA2Opt.present()) {
              nRes = n0ChNSeq0A3NloEiSeqA2Opt.accept(this, argu);
            }
          }
        }
        final INode n0ChNSeq0A4 = n0ChNSeq0.elementAt(4);
        final NodeOptional n0ChNSeq0A4Opt = (NodeOptional) n0ChNSeq0A4;
        if (n0ChNSeq0A4Opt.present()) {
          final NodeSequence n0ChNSeq0A4OptSeq = (NodeSequence) n0ChNSeq0A4Opt.node;
          final INode n0ChNSeq0A4OptSeqA0 = n0ChNSeq0A4OptSeq.elementAt(0);
          final NodeListOptional n0ChNSeq0A4OptSeqA0Nlo = (NodeListOptional) n0ChNSeq0A4OptSeqA0;
          if (n0ChNSeq0A4OptSeqA0Nlo.present()) {
            for (int i = 0; i < n0ChNSeq0A4OptSeqA0Nlo.size(); i++) {
              final INode n0ChNSeq0A4OptSeqA0NloEi = n0ChNSeq0A4OptSeqA0Nlo.elementAt(i);
              nRes = n0ChNSeq0A4OptSeqA0NloEi.accept(this, argu);
            }
          }
          final INode n0ChNSeq0A4OptSeqA1 = n0ChNSeq0A4OptSeq.elementAt(1);
          nRes = n0ChNSeq0A4OptSeqA1.accept(this, argu);
          final INode n0ChNSeq0A4OptSeqA2 = n0ChNSeq0A4OptSeq.elementAt(2);
          final NodeListOptional n0ChNSeq0A4OptSeqA2Nlo = (NodeListOptional) n0ChNSeq0A4OptSeqA2;
          if (n0ChNSeq0A4OptSeqA2Nlo.present()) {
            for (int i = 0; i < n0ChNSeq0A4OptSeqA2Nlo.size(); i++) {
              final INode n0ChNSeq0A4OptSeqA2NloEi = n0ChNSeq0A4OptSeqA2Nlo.elementAt(i);
              nRes = n0ChNSeq0A4OptSeqA2NloEi.accept(this, argu);
            }
          }
          final INode n0ChNSeq0A4OptSeqA3 = n0ChNSeq0A4OptSeq.elementAt(3);
          nRes = n0ChNSeq0A4OptSeqA3.accept(this, argu);
        }
        break;
      case 1:
        final NodeSequence n0ChNSeq1 = (NodeSequence) n0ChN;
        final INode n0ChNSeq1A0 = n0ChNSeq1.elementAt(0);
        nRes = n0ChNSeq1A0.accept(this, argu);
        final INode n0ChNSeq1A1 = n0ChNSeq1.elementAt(1);
        final NodeListOptional n0ChNSeq1A1Nlo = (NodeListOptional) n0ChNSeq1A1;
        if (n0ChNSeq1A1Nlo.present()) {
          for (int i = 0; i < n0ChNSeq1A1Nlo.size(); i++) {
            final INode n0ChNSeq1A1NloEi = n0ChNSeq1A1Nlo.elementAt(i);
            nRes = n0ChNSeq1A1NloEi.accept(this, argu);
          }
        }
        final INode n0ChNSeq1A2 = n0ChNSeq1.elementAt(2);
        final NodeOptional n0ChNSeq1A2Opt = (NodeOptional) n0ChNSeq1A2;
        if (n0ChNSeq1A2Opt.present()) {
          nRes = n0ChNSeq1A2Opt.accept(this, argu);
        }
        final INode n0ChNSeq1A3 = n0ChNSeq1.elementAt(3);
        final NodeOptional n0ChNSeq1A3Opt = (NodeOptional) n0ChNSeq1A3;
        if (n0ChNSeq1A3Opt.present()) {
          final NodeSequence n0ChNSeq1A3OptSeq = (NodeSequence) n0ChNSeq1A3Opt.node;
          final INode n0ChNSeq1A3OptSeqA0 = n0ChNSeq1A3OptSeq.elementAt(0);
          final NodeListOptional n0ChNSeq1A3OptSeqA0Nlo = (NodeListOptional) n0ChNSeq1A3OptSeqA0;
          if (n0ChNSeq1A3OptSeqA0Nlo.present()) {
            for (int i = 0; i < n0ChNSeq1A3OptSeqA0Nlo.size(); i++) {
              final INode n0ChNSeq1A3OptSeqA0NloEi = n0ChNSeq1A3OptSeqA0Nlo.elementAt(i);
              nRes = n0ChNSeq1A3OptSeqA0NloEi.accept(this, argu);
            }
          }
          final INode n0ChNSeq1A3OptSeqA1 = n0ChNSeq1A3OptSeq.elementAt(1);
          nRes = n0ChNSeq1A3OptSeqA1.accept(this, argu);
          final INode n0ChNSeq1A3OptSeqA2 = n0ChNSeq1A3OptSeq.elementAt(2);
          final NodeListOptional n0ChNSeq1A3OptSeqA2Nlo = (NodeListOptional) n0ChNSeq1A3OptSeqA2;
          if (n0ChNSeq1A3OptSeqA2Nlo.present()) {
            for (int i = 0; i < n0ChNSeq1A3OptSeqA2Nlo.size(); i++) {
              final INode n0ChNSeq1A3OptSeqA2NloEi = n0ChNSeq1A3OptSeqA2Nlo.elementAt(i);
              nRes = n0ChNSeq1A3OptSeqA2NloEi.accept(this, argu);
            }
          }
          final INode n0ChNSeq1A3OptSeqA3 = n0ChNSeq1A3OptSeq.elementAt(3);
          nRes = n0ChNSeq1A3OptSeqA3.accept(this, argu);
        }
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link AdditiveExpression} node, whose children are the following :
   * <p>
   * speciesWithCoeff -> SpeciesWithCoeff()<br>
   * nodeListOptional -> ( #0 ( Blank() )* #1 " + "<br>
   * ................ .. . #2 ( Blank() )* #3 SpeciesWithCoeff() )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final AdditiveExpression n, final A argu) {
    R nRes = null;
    final SpeciesWithCoeff n0 = n.speciesWithCoeff;
    nRes = n0.accept(this, argu);
    final NodeListOptional n1 = n.nodeListOptional;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Ei = n1.elementAt(i);
        final NodeSequence n1EiSeq = (NodeSequence) n1Ei;
        final INode n1EiSeqA0 = n1EiSeq.elementAt(0);
        final NodeListOptional n1EiSeqA0Nlo = (NodeListOptional) n1EiSeqA0;
        if (n1EiSeqA0Nlo.present()) {
          for (int i1 = 0; i1 < n1EiSeqA0Nlo.size(); i1++) {
            final INode n1EiSeqA0NloEi = n1EiSeqA0Nlo.elementAt(i1);
            nRes = n1EiSeqA0NloEi.accept(this, argu);
          }
        }
        final INode n1EiSeqA1 = n1EiSeq.elementAt(1);
        nRes = n1EiSeqA1.accept(this, argu);
        final INode n1EiSeqA2 = n1EiSeq.elementAt(2);
        final NodeListOptional n1EiSeqA2Nlo = (NodeListOptional) n1EiSeqA2;
        if (n1EiSeqA2Nlo.present()) {
          for (int i1 = 0; i1 < n1EiSeqA2Nlo.size(); i1++) {
            final INode n1EiSeqA2NloEi = n1EiSeqA2Nlo.elementAt(i1);
            nRes = n1EiSeqA2NloEi.accept(this, argu);
          }
        }
        final INode n1EiSeqA3 = n1EiSeq.elementAt(3);
        nRes = n1EiSeqA3.accept(this, argu);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link SpeciesWithCoeff} node, whose children are the following :
   * <p>
   * nodeOptional -> ( #0 Stoichiometry()<br>
   * ............ .. . #1 ( Blank() )* #2 " * "<br>
   * ............ .. . #3 ( Blank() )* )?<br>
   * species -> Species()<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final SpeciesWithCoeff n, final A argu) {
    R nRes = null;
    final NodeOptional n0 = n.nodeOptional;
    if (n0.present()) {
      final NodeSequence n0Seq = (NodeSequence) n0.node;
      final INode n0SeqA0 = n0Seq.elementAt(0);
      nRes = n0SeqA0.accept(this, argu);
      final INode n0SeqA1 = n0Seq.elementAt(1);
      final NodeListOptional n0SeqA1Nlo = (NodeListOptional) n0SeqA1;
      if (n0SeqA1Nlo.present()) {
        for (int i = 0; i < n0SeqA1Nlo.size(); i++) {
          final INode n0SeqA1NloEi = n0SeqA1Nlo.elementAt(i);
          nRes = n0SeqA1NloEi.accept(this, argu);
        }
      }
      final INode n0SeqA2 = n0Seq.elementAt(2);
      nRes = n0SeqA2.accept(this, argu);
      final INode n0SeqA3 = n0Seq.elementAt(3);
      final NodeListOptional n0SeqA3Nlo = (NodeListOptional) n0SeqA3;
      if (n0SeqA3Nlo.present()) {
        for (int i = 0; i < n0SeqA3Nlo.size(); i++) {
          final INode n0SeqA3NloEi = n0SeqA3Nlo.elementAt(i);
          nRes = n0SeqA3NloEi.accept(this, argu);
        }
      }
    }
    final Species n1 = n.species;
    nRes = n1.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link Blank} node, whose children are the following :
   * <p>
   * nodeToken -> " "<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final Blank n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.nodeToken;
    nRes = n0.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link ListModifiers} node, whose children are the following :
   * <p>
   * species -> Species()<br>
   * nodeListOptional -> ( #0 ( Blank() )+ #1 Species() )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final ListModifiers n, final A argu) {
    R nRes = null;
    final Species n0 = n.species;
    nRes = n0.accept(this, argu);
    final NodeListOptional n1 = n.nodeListOptional;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Ei = n1.elementAt(i);
        final NodeSequence n1EiSeq = (NodeSequence) n1Ei;
        final INode n1EiSeqA0 = n1EiSeq.elementAt(0);
        final NodeList n1EiSeqA0Lst = (NodeList) n1EiSeqA0;
        for (int i1 = 0; i1 < n1EiSeqA0Lst.size(); i1++) {
          final INode n1EiSeqA0LstEi = n1EiSeqA0Lst.elementAt(i1);
          nRes = n1EiSeqA0LstEi.accept(this, argu);
        }
        final INode n1EiSeqA1 = n1EiSeq.elementAt(1);
        nRes = n1EiSeqA1.accept(this, argu);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link Species} node, whose children are the following :
   * <p>
   * nodeToken -> < IDENTIFIER ><br>
   * nodeListOptional -> ( < IDENTIFIER > )*<br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final Species n, final A argu) {
    R nRes = null;
    final NodeToken n0 = n.nodeToken;
    nRes = n0.accept(this, argu);
    final NodeListOptional n1 = n.nodeListOptional;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Ei = n1.elementAt(i);
        nRes = n1Ei.accept(this, argu);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link Stoichiometry} node, whose children are the following :
   * <p>
   * nodeChoice -> . %0 < INTEGER_LITERAL ><br>
   * .......... .. | %1 < FLOATING_POINT_LITERAL ><br>
   *
   * @param n the node to visit
   * @param argu the user argument
   * @return the user return information
   */
  public R visit(final Stoichiometry n, final A argu) {
    R nRes = null;
    final NodeChoice n0Ch = n.nodeChoice;
    final INode n0ChN = n0Ch.choice;
    switch (n0Ch.which) {
      case 0:
        nRes = n0ChN.accept(this, argu);
        break;
      case 1:
        nRes = n0ChN.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

}
